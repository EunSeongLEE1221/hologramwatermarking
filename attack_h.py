import os
import numpy as np
import tensorflow as tf
from PIL import Image
import scipy

## Num. 1
def Gaussian_filtering(inp, kernel=5, sigma=1, name='Attack_1'):
    if ((kernel==3)&(sigma==0.5)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [1, 1], [1, 1], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.024879]], [[0.107973]], [[0.024879]]], 
                             [[[0.107973]], [[0.468592]], [[0.107973]]], 
                             [[[0.024879]], [[0.107973]], [[0.024879]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==5)&(sigma==1)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [2, 2], [2, 2], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.003765]], [[0.015019]], [[0.023792]], [[0.015019]], [[0.003765]]],
                             [[[0.015019]], [[0.059912]], [[0.094907]], [[0.059912]], [[0.015019]]],
                             [[[0.023792]], [[0.094907]], [[0.150342]], [[0.094907]], [[0.023792]]], 
                             [[[0.015019]], [[0.059912]], [[0.094907]], [[0.059912]], [[0.015019]]], 
                             [[[0.003765]], [[0.015019]], [[0.023792]], [[0.015019]], [[0.003765]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==7)&(sigma==1.5)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [3, 3], [3, 3], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.001500]], [[0.004380]], [[0.008328]], [[0.010317]], [[0.008328]], [[0.004380]], [[0.001500]]],
                             [[[0.004380]], [[0.012788]], [[0.024314]], [[0.030120]], [[0.024314]], [[0.012788]], [[0.004380]]],
                             [[[0.008328]], [[0.024314]], [[0.046228]], [[0.057266]], [[0.046228]], [[0.024314]], [[0.008328]]], 
                             [[[0.010317]], [[0.030120]], [[0.057266]], [[0.070940]], [[0.057266]], [[0.030120]], [[0.010317]]],
                             [[[0.008328]], [[0.024314]], [[0.046228]], [[0.057266]], [[0.046228]], [[0.024314]], [[0.008328]]], 
                             [[[0.004380]], [[0.012788]], [[0.024314]], [[0.030120]], [[0.024314]], [[0.012788]], [[0.004380]]], 
                             [[[0.001500]], [[0.004380]], [[0.008328]], [[0.010317]], [[0.008328]], [[0.004380]], [[0.001500]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==9)&(sigma==2)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [4, 4], [4, 4], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.000814]], [[0.001918]], [[0.003538]], [[0.005108]], [[0.005774]], [[0.005108]], [[0.003538]], [[0.001918]], [[0.000814]]],
                             [[[0.001918]], [[0.004520]], [[0.008338]], [[0.012038]], [[0.013605]], [[0.012038]], [[0.008338]], [[0.004520]], [[0.001918]]],
                             [[[0.003538]], [[0.008338]], [[0.015378]], [[0.022203]], [[0.025094]], [[0.022203]], [[0.015378]], [[0.008338]], [[0.003538]]], 
                             [[[0.005108]], [[0.012038]], [[0.022203]], [[0.032057]], [[0.036231]], [[0.032057]], [[0.022203]], [[0.012038]], [[0.005108]]],
                             [[[0.005774]], [[0.013605]], [[0.025094]], [[0.036231]], [[0.040950]], [[0.036231]], [[0.025094]], [[0.013605]], [[0.005774]]], 
                             [[[0.005108]], [[0.012038]], [[0.022203]], [[0.032057]], [[0.036231]], [[0.032057]], [[0.022203]], [[0.012038]], [[0.005108]]],
                             [[[0.003538]], [[0.008338]], [[0.015378]], [[0.022203]], [[0.025094]], [[0.022203]], [[0.015378]], [[0.008338]], [[0.003538]]], 
                             [[[0.001918]], [[0.004520]], [[0.008338]], [[0.012038]], [[0.013605]], [[0.012038]], [[0.008338]], [[0.004520]], [[0.001918]]], 
                             [[[0.000814]], [[0.001918]], [[0.003538]], [[0.005108]], [[0.005774]], [[0.005108]], [[0.003538]], [[0.001918]], [[0.000814]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==11)&(sigma==2.5)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [5, 5], [5, 5], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.000513]], [[0.001045]], [[0.001815]], [[0.002694]], [[0.003414]], [[0.003694]], [[0.003414]], [[0.002694]], [[0.001815]], [[0.001045]], [[0.000513]]],
                             [[[0.001045]], [[0.002126]], [[0.003694]], [[0.005482]], [[0.006947]], [[0.007518]], [[0.006947]], [[0.005482]], [[0.003694]], [[0.002126]], [[0.001045]]],
                             [[[0.001815]], [[0.003694]], [[0.00642 ]], [[0.009527]], [[0.012073]], [[0.013065]], [[0.012073]], [[0.009527]], [[0.00642 ]], [[0.003694]], [[0.001815]]],
                             [[[0.002694]], [[0.005482]], [[0.009527]], [[0.014138]], [[0.017916]], [[0.019388]], [[0.017916]], [[0.014138]], [[0.009527]], [[0.005482]], [[0.002694]]],
                             [[[0.003414]], [[0.006947]], [[0.012073]], [[0.017916]], [[0.022704]], [[0.024568]], [[0.022704]], [[0.017916]], [[0.012073]], [[0.006947]], [[0.003414]]],
                             [[[0.003694]], [[0.007518]], [[0.013065]], [[0.019388]], [[0.024568]], [[0.026586]], [[0.024568]], [[0.019388]], [[0.013065]], [[0.007518]], [[0.003694]]],
                             [[[0.003414]], [[0.006947]], [[0.012073]], [[0.017916]], [[0.022704]], [[0.024568]], [[0.022704]], [[0.017916]], [[0.012073]], [[0.006947]], [[0.003414]]],
                             [[[0.002694]], [[0.005482]], [[0.009527]], [[0.014138]], [[0.017916]], [[0.019388]], [[0.017916]], [[0.014138]], [[0.009527]], [[0.005482]], [[0.002694]]],
                             [[[0.001815]], [[0.003694]], [[0.00642 ]], [[0.009527]], [[0.012073]], [[0.013065]], [[0.012073]], [[0.009527]], [[0.00642 ]], [[0.003694]], [[0.001815]]],
                             [[[0.001045]], [[0.002126]], [[0.003694]], [[0.005482]], [[0.006947]], [[0.007518]], [[0.006947]], [[0.005482]], [[0.003694]], [[0.002126]], [[0.001045]]],
                             [[[0.000513]], [[0.001045]], [[0.001815]], [[0.002694]], [[0.003414]], [[0.003694]], [[0.003414]], [[0.002694]], [[0.001815]], [[0.001045]], [[0.000513]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==13)&(sigma==3)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [6, 6], [6, 6], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.000354]], [[0.000649]], [[0.001065]], [[0.001565]], [[0.002061]], [[0.002431]], [[0.002568]], [[0.002431]], [[0.002061]], [[0.001565]], [[0.001065]], [[0.000649]], [[0.000354]]],
                             [[[0.000649]], [[0.001188]], [[0.001950]], [[0.002867]], [[0.003776]], [[0.004454]], [[0.004706]], [[0.004454]], [[0.003776]], [[0.002867]], [[0.001950]], [[0.001188]], [[0.000649]]],
                             [[[0.001065]], [[0.001950]], [[0.003201]], [[0.004706]], [[0.006196]], [[0.007309]], [[0.007723]], [[0.007309]], [[0.006196]], [[0.004706]], [[0.003201]], [[0.001950]], [[0.001065]]],
                             [[[0.001565]], [[0.002867]], [[0.004706]], [[0.006918]], [[0.009109]], [[0.010745]], [[0.011353]], [[0.010745]], [[0.009109]], [[0.006918]], [[0.004706]], [[0.002867]], [[0.001565]]],
                             [[[0.002061]], [[0.003776]], [[0.006196]], [[0.009109]], [[0.011995]], [[0.014149]], [[0.014950]], [[0.014149]], [[0.011995]], [[0.009109]], [[0.006196]], [[0.003776]], [[0.002061]]],
                             [[[0.002431]], [[0.004454]], [[0.007309]], [[0.010745]], [[0.014149]], [[0.016690]], [[0.017634]], [[0.016690]], [[0.014149]], [[0.010745]], [[0.007309]], [[0.004454]], [[0.002431]]],
                             [[[0.002568]], [[0.004706]], [[0.007723]], [[0.011353]], [[0.014950]], [[0.017634]], [[0.018632]], [[0.017634]], [[0.014950]], [[0.011353]], [[0.007723]], [[0.004706]], [[0.002568]]],
                             [[[0.002431]], [[0.004454]], [[0.007309]], [[0.010745]], [[0.014149]], [[0.016690]], [[0.017634]], [[0.016690]], [[0.014149]], [[0.010745]], [[0.007309]], [[0.004454]], [[0.002431]]],
                             [[[0.002061]], [[0.003776]], [[0.006196]], [[0.009109]], [[0.011995]], [[0.014149]], [[0.014950]], [[0.014149]], [[0.011995]], [[0.009109]], [[0.006196]], [[0.003776]], [[0.002061]]],
                             [[[0.001565]], [[0.002867]], [[0.004706]], [[0.006918]], [[0.009109]], [[0.010745]], [[0.011353]], [[0.010745]], [[0.009109]], [[0.006918]], [[0.004706]], [[0.002867]], [[0.001565]]],
                             [[[0.001065]], [[0.001950]], [[0.003201]], [[0.004706]], [[0.006196]], [[0.007309]], [[0.007723]], [[0.007309]], [[0.006196]], [[0.004706]], [[0.003201]], [[0.001950]], [[0.001065]]],
                             [[[0.000649]], [[0.001188]], [[0.001950]], [[0.002867]], [[0.003776]], [[0.004454]], [[0.004706]], [[0.004454]], [[0.003776]], [[0.002867]], [[0.001950]], [[0.001188]], [[0.000649]]],
                             [[[0.000354]], [[0.000649]], [[0.001065]], [[0.001565]], [[0.002061]], [[0.002431]], [[0.002568]], [[0.002431]], [[0.002061]], [[0.001565]], [[0.001065]], [[0.000649]], [[0.000354]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==15)&(sigma==3.5)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [7, 7], [7, 7], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.000259]], [[0.000439]], [[0.000686]], [[0.000988]], [[0.001312]], [[0.001607]], [[0.001815]], [[0.001890]], [[0.001815]], [[0.001607]], [[0.001312]], [[0.000988]], [[0.000686]], [[0.000439]],  [[0.000259]]],
                             [[[0.000439]], [[0.000744]], [[0.001162]], [[0.001673]], [[0.002222]], [[0.002722]], [[0.003074]], [[0.003201]], [[0.003074]], [[0.002722]], [[0.002222]], [[0.001673]], [[0.001162]], [[0.000744]],  [[0.000439]]],
                             [[[0.000686]], [[0.001162]], [[0.001815]], [[0.002614]], [[0.003471]], [[0.004251]], [[0.004801]], [[0.005000]], [[0.004801]], [[0.004251]], [[0.003471]], [[0.002614]], [[0.001815]], [[0.001162]],  [[0.000686]]],
                             [[[0.000988]], [[0.001673]], [[0.002614]], [[0.003764]], [[0.005000]], [[0.006123]], [[0.006915]], [[0.007201]], [[0.006915]], [[0.006123]], [[0.005000]], [[0.003764]], [[0.002614]], [[0.001673]],  [[0.000988]]],
                             [[[0.001312]], [[0.002222]], [[0.003471]], [[0.005000]], [[0.006640]], [[0.008132]], [[0.009184]], [[0.009564]], [[0.009184]], [[0.008132]], [[0.006640]], [[0.005000]], [[0.003471]], [[0.002222]],  [[0.001312]]],
                             [[[0.001607]], [[0.002722]], [[0.004251]], [[0.006123]], [[0.008132]], [[0.009960]], [[0.011248]], [[0.011713]], [[0.011248]], [[0.009960]], [[0.008132]], [[0.006123]], [[0.004251]], [[0.002722]],  [[0.001607]]],
                             [[[0.001815]], [[0.003074]], [[0.004801]], [[0.006915]], [[0.009184]], [[0.011248]], [[0.012702]], [[0.013228]], [[0.012702]], [[0.011248]], [[0.009184]], [[0.006915]], [[0.004801]], [[0.003074]],  [[0.001815]]],
                             [[[0.001890]], [[0.003201]], [[0.005000]], [[0.007201]], [[0.009564]], [[0.011713]], [[0.013228]], [[0.013775]], [[0.013228]], [[0.011713]], [[0.009564]], [[0.007201]], [[0.005000]], [[0.003201]],  [[0.001890]]],
                             [[[0.001815]], [[0.003074]], [[0.004801]], [[0.006915]], [[0.009184]], [[0.011248]], [[0.012702]], [[0.013228]], [[0.012702]], [[0.011248]], [[0.009184]], [[0.006915]], [[0.004801]], [[0.003074]],  [[0.001815]]],
                             [[[0.001607]], [[0.002722]], [[0.004251]], [[0.006123]], [[0.008132]], [[0.009960]], [[0.011248]], [[0.011713]], [[0.011248]], [[0.009960]], [[0.008132]], [[0.006123]], [[0.004251]], [[0.002722]],  [[0.001607]]],
                             [[[0.001312]], [[0.002222]], [[0.003471]], [[0.005000]], [[0.006640]], [[0.008132]], [[0.009184]], [[0.009564]], [[0.009184]], [[0.008132]], [[0.006640]], [[0.005000]], [[0.003471]], [[0.002222]],  [[0.001312]]],
                             [[[0.000988]], [[0.001673]], [[0.002614]], [[0.003764]], [[0.005000]], [[0.006123]], [[0.006915]], [[0.007201]], [[0.006915]], [[0.006123]], [[0.005000]], [[0.003764]], [[0.002614]], [[0.001673]],  [[0.000988]]],
                             [[[0.000686]], [[0.001162]], [[0.001815]], [[0.002614]], [[0.003471]], [[0.004251]], [[0.004801]], [[0.005000]], [[0.004801]], [[0.004251]], [[0.003471]], [[0.002614]], [[0.001815]], [[0.001162]],  [[0.000686]]],
                             [[[0.000439]], [[0.000744]], [[0.001162]], [[0.001673]], [[0.002222]], [[0.002722]], [[0.003074]], [[0.003201]], [[0.003074]], [[0.002722]], [[0.002222]], [[0.001673]], [[0.001162]], [[0.000744]],  [[0.000439]]],
                             [[[0.000259]], [[0.000439]], [[0.000686]], [[0.000988]], [[0.001312]], [[0.001607]], [[0.001815]], [[0.001890]], [[0.001815]], [[0.001607]], [[0.001312]], [[0.000988]], [[0.000686]], [[0.000439]],  [[0.000259]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==17)&(sigma==4)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [8, 8], [8, 8], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.000198]], [[0.000316]], [[0.000473]], [[0.000666]], [[0.000881]], [[0.001095]], [[0.001279]], [[0.001405]], [[0.001449]], [[0.001405]], [[0.001279]], [[0.001095]], [[0.000881]], [[0.000666]], [[0.000473]], [[0.000316]],  [[0.000198]]],
                             [[[0.000316]], [[0.000504]], [[0.000754]], [[0.001062]], [[0.001405]], [[0.001746]], [[0.002040]], [[0.002239]], [[0.002310]], [[0.002239]], [[0.002040]], [[0.001746]], [[0.001405]], [[0.001062]], [[0.000754]], [[0.000504]],  [[0.000316]]],
                             [[[0.000473]], [[0.000754]], [[0.001130]], [[0.001590]], [[0.002104]], [[0.002615]], [[0.003055]], [[0.003354]], [[0.003460]], [[0.003354]], [[0.003055]], [[0.002615]], [[0.002104]], [[0.001590]], [[0.001130]], [[0.000754]],  [[0.000473]]],
                             [[[0.000666]], [[0.001062]], [[0.001590]], [[0.002239]], [[0.002962]], [[0.003682]], [[0.004301]], [[0.004722]], [[0.004871]], [[0.004722]], [[0.004301]], [[0.003682]], [[0.002962]], [[0.002239]], [[0.001590]], [[0.001062]],  [[0.000666]]],
                             [[[0.000881]], [[0.001405]], [[0.002104]], [[0.002962]], [[0.003918]], [[0.004871]], [[0.005690]], [[0.006246]], [[0.006443]], [[0.006246]], [[0.005690]], [[0.004871]], [[0.003918]], [[0.002962]], [[0.002104]], [[0.001405]],  [[0.000881]]],
                             [[[0.001095]], [[0.001746]], [[0.002615]], [[0.003682]], [[0.004871]], [[0.006055]], [[0.007073]], [[0.007764]], [[0.008010]], [[0.007764]], [[0.007073]], [[0.006055]], [[0.004871]], [[0.003682]], [[0.002615]], [[0.001746]],  [[0.001095]]],
                             [[[0.001279]], [[0.002040]], [[0.003055]], [[0.004301]], [[0.005690]], [[0.007073]], [[0.008262]], [[0.009070]], [[0.009356]], [[0.009070]], [[0.008262]], [[0.007073]], [[0.005690]], [[0.004301]], [[0.003055]], [[0.002040]],  [[0.001279]]],
                             [[[0.001405]], [[0.002239]], [[0.003354]], [[0.004722]], [[0.006246]], [[0.007764]], [[0.009070]], [[0.009957]], [[0.010271]], [[0.009957]], [[0.009070]], [[0.007764]], [[0.006246]], [[0.004722]], [[0.003354]], [[0.002239]],  [[0.001405]]],
                             [[[0.001449]], [[0.002310]], [[0.003460]], [[0.004871]], [[0.006443]], [[0.008010]], [[0.009356]], [[0.010271]], [[0.010595]], [[0.010271]], [[0.009356]], [[0.008010]], [[0.006443]], [[0.004871]], [[0.003460]], [[0.002310]],  [[0.001449]]],
                             [[[0.001405]], [[0.002239]], [[0.003354]], [[0.004722]], [[0.006246]], [[0.007764]], [[0.009070]], [[0.009957]], [[0.010271]], [[0.009957]], [[0.009070]], [[0.007764]], [[0.006246]], [[0.004722]], [[0.003354]], [[0.002239]],  [[0.001405]]],
                             [[[0.001279]], [[0.002040]], [[0.003055]], [[0.004301]], [[0.005690]], [[0.007073]], [[0.008262]], [[0.009070]], [[0.009356]], [[0.009070]], [[0.008262]], [[0.007073]], [[0.005690]], [[0.004301]], [[0.003055]], [[0.002040]],  [[0.001279]]],
                             [[[0.001095]], [[0.001746]], [[0.002615]], [[0.003682]], [[0.004871]], [[0.006055]], [[0.007073]], [[0.007764]], [[0.008010]], [[0.007764]], [[0.007073]], [[0.006055]], [[0.004871]], [[0.003682]], [[0.002615]], [[0.001746]],  [[0.001095]]],
                             [[[0.000881]], [[0.001405]], [[0.002104]], [[0.002962]], [[0.003918]], [[0.004871]], [[0.005690]], [[0.006246]], [[0.006443]], [[0.006246]], [[0.005690]], [[0.004871]], [[0.003918]], [[0.002962]], [[0.002104]], [[0.001405]],  [[0.000881]]],
                             [[[0.000666]], [[0.001062]], [[0.001590]], [[0.002239]], [[0.002962]], [[0.003682]], [[0.004301]], [[0.004722]], [[0.004871]], [[0.004722]], [[0.004301]], [[0.003682]], [[0.002962]], [[0.002239]], [[0.001590]], [[0.001062]],  [[0.000666]]],
                             [[[0.000473]], [[0.000754]], [[0.001130]], [[0.001590]], [[0.002104]], [[0.002615]], [[0.003055]], [[0.003354]], [[0.003460]], [[0.003354]], [[0.003055]], [[0.002615]], [[0.002104]], [[0.001590]], [[0.001130]], [[0.000754]],  [[0.000473]]],
                             [[[0.000316]], [[0.000504]], [[0.000754]], [[0.001062]], [[0.001405]], [[0.001746]], [[0.002040]], [[0.002239]], [[0.002310]], [[0.002239]], [[0.002040]], [[0.001746]], [[0.001405]], [[0.001062]], [[0.000754]], [[0.000504]],  [[0.000316]]],
                             [[[0.000198]], [[0.000316]], [[0.000473]], [[0.000666]], [[0.000881]], [[0.001095]], [[0.001279]], [[0.001405]], [[0.001449]], [[0.001405]], [[0.001279]], [[0.001095]], [[0.000881]], [[0.000666]], [[0.000473]], [[0.000316]],  [[0.000198]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net

def Gaussian_filtering_test(inp, kernel=5, sigma=1, name='Attack_1'):
    if ((kernel==3)&(sigma==0.5)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [1, 1], [1, 1], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.024879]], [[0.107973]], [[0.024879]]], 
                             [[[0.107973]], [[0.468592]], [[0.107973]]], 
                             [[[0.024879]], [[0.107973]], [[0.024879]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==5)&(sigma==1)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [2, 2], [2, 2], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.003765]], [[0.015019]], [[0.023792]], [[0.015019]], [[0.003765]]],
                             [[[0.015019]], [[0.059912]], [[0.094907]], [[0.059912]], [[0.015019]]],
                             [[[0.023792]], [[0.094907]], [[0.150342]], [[0.094907]], [[0.023792]]], 
                             [[[0.015019]], [[0.059912]], [[0.094907]], [[0.059912]], [[0.015019]]], 
                             [[[0.003765]], [[0.015019]], [[0.023792]], [[0.015019]], [[0.003765]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==7)&(sigma==1.5)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [3, 3], [3, 3], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.001500]], [[0.004380]], [[0.008328]], [[0.010317]], [[0.008328]], [[0.004380]], [[0.001500]]],
                             [[[0.004380]], [[0.012788]], [[0.024314]], [[0.030120]], [[0.024314]], [[0.012788]], [[0.004380]]],
                             [[[0.008328]], [[0.024314]], [[0.046228]], [[0.057266]], [[0.046228]], [[0.024314]], [[0.008328]]], 
                             [[[0.010317]], [[0.030120]], [[0.057266]], [[0.070940]], [[0.057266]], [[0.030120]], [[0.010317]]],
                             [[[0.008328]], [[0.024314]], [[0.046228]], [[0.057266]], [[0.046228]], [[0.024314]], [[0.008328]]], 
                             [[[0.004380]], [[0.012788]], [[0.024314]], [[0.030120]], [[0.024314]], [[0.012788]], [[0.004380]]], 
                             [[[0.001500]], [[0.004380]], [[0.008328]], [[0.010317]], [[0.008328]], [[0.004380]], [[0.001500]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==9)&(sigma==2)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [4, 4], [4, 4], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.000814]], [[0.001918]], [[0.003538]], [[0.005108]], [[0.005774]], [[0.005108]], [[0.003538]], [[0.001918]], [[0.000814]]],
                             [[[0.001918]], [[0.004520]], [[0.008338]], [[0.012038]], [[0.013605]], [[0.012038]], [[0.008338]], [[0.004520]], [[0.001918]]],
                             [[[0.003538]], [[0.008338]], [[0.015378]], [[0.022203]], [[0.025094]], [[0.022203]], [[0.015378]], [[0.008338]], [[0.003538]]], 
                             [[[0.005108]], [[0.012038]], [[0.022203]], [[0.032057]], [[0.036231]], [[0.032057]], [[0.022203]], [[0.012038]], [[0.005108]]],
                             [[[0.005774]], [[0.013605]], [[0.025094]], [[0.036231]], [[0.040950]], [[0.036231]], [[0.025094]], [[0.013605]], [[0.005774]]], 
                             [[[0.005108]], [[0.012038]], [[0.022203]], [[0.032057]], [[0.036231]], [[0.032057]], [[0.022203]], [[0.012038]], [[0.005108]]],
                             [[[0.003538]], [[0.008338]], [[0.015378]], [[0.022203]], [[0.025094]], [[0.022203]], [[0.015378]], [[0.008338]], [[0.003538]]], 
                             [[[0.001918]], [[0.004520]], [[0.008338]], [[0.012038]], [[0.013605]], [[0.012038]], [[0.008338]], [[0.004520]], [[0.001918]]], 
                             [[[0.000814]], [[0.001918]], [[0.003538]], [[0.005108]], [[0.005774]], [[0.005108]], [[0.003538]], [[0.001918]], [[0.000814]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==11)&(sigma==2.5)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [5, 5], [5, 5], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.000513]], [[0.001045]], [[0.001815]], [[0.002694]], [[0.003414]], [[0.003694]], [[0.003414]], [[0.002694]], [[0.001815]], [[0.001045]], [[0.000513]]],
                             [[[0.001045]], [[0.002126]], [[0.003694]], [[0.005482]], [[0.006947]], [[0.007518]], [[0.006947]], [[0.005482]], [[0.003694]], [[0.002126]], [[0.001045]]],
                             [[[0.001815]], [[0.003694]], [[0.00642 ]], [[0.009527]], [[0.012073]], [[0.013065]], [[0.012073]], [[0.009527]], [[0.00642 ]], [[0.003694]], [[0.001815]]],
                             [[[0.002694]], [[0.005482]], [[0.009527]], [[0.014138]], [[0.017916]], [[0.019388]], [[0.017916]], [[0.014138]], [[0.009527]], [[0.005482]], [[0.002694]]],
                             [[[0.003414]], [[0.006947]], [[0.012073]], [[0.017916]], [[0.022704]], [[0.024568]], [[0.022704]], [[0.017916]], [[0.012073]], [[0.006947]], [[0.003414]]],
                             [[[0.003694]], [[0.007518]], [[0.013065]], [[0.019388]], [[0.024568]], [[0.026586]], [[0.024568]], [[0.019388]], [[0.013065]], [[0.007518]], [[0.003694]]],
                             [[[0.003414]], [[0.006947]], [[0.012073]], [[0.017916]], [[0.022704]], [[0.024568]], [[0.022704]], [[0.017916]], [[0.012073]], [[0.006947]], [[0.003414]]],
                             [[[0.002694]], [[0.005482]], [[0.009527]], [[0.014138]], [[0.017916]], [[0.019388]], [[0.017916]], [[0.014138]], [[0.009527]], [[0.005482]], [[0.002694]]],
                             [[[0.001815]], [[0.003694]], [[0.00642 ]], [[0.009527]], [[0.012073]], [[0.013065]], [[0.012073]], [[0.009527]], [[0.00642 ]], [[0.003694]], [[0.001815]]],
                             [[[0.001045]], [[0.002126]], [[0.003694]], [[0.005482]], [[0.006947]], [[0.007518]], [[0.006947]], [[0.005482]], [[0.003694]], [[0.002126]], [[0.001045]]],
                             [[[0.000513]], [[0.001045]], [[0.001815]], [[0.002694]], [[0.003414]], [[0.003694]], [[0.003414]], [[0.002694]], [[0.001815]], [[0.001045]], [[0.000513]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==13)&(sigma==3)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [6, 6], [6, 6], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.000354]], [[0.000649]], [[0.001065]], [[0.001565]], [[0.002061]], [[0.002431]], [[0.002568]], [[0.002431]], [[0.002061]], [[0.001565]], [[0.001065]], [[0.000649]], [[0.000354]]],
                             [[[0.000649]], [[0.001188]], [[0.001950]], [[0.002867]], [[0.003776]], [[0.004454]], [[0.004706]], [[0.004454]], [[0.003776]], [[0.002867]], [[0.001950]], [[0.001188]], [[0.000649]]],
                             [[[0.001065]], [[0.001950]], [[0.003201]], [[0.004706]], [[0.006196]], [[0.007309]], [[0.007723]], [[0.007309]], [[0.006196]], [[0.004706]], [[0.003201]], [[0.001950]], [[0.001065]]],
                             [[[0.001565]], [[0.002867]], [[0.004706]], [[0.006918]], [[0.009109]], [[0.010745]], [[0.011353]], [[0.010745]], [[0.009109]], [[0.006918]], [[0.004706]], [[0.002867]], [[0.001565]]],
                             [[[0.002061]], [[0.003776]], [[0.006196]], [[0.009109]], [[0.011995]], [[0.014149]], [[0.014950]], [[0.014149]], [[0.011995]], [[0.009109]], [[0.006196]], [[0.003776]], [[0.002061]]],
                             [[[0.002431]], [[0.004454]], [[0.007309]], [[0.010745]], [[0.014149]], [[0.016690]], [[0.017634]], [[0.016690]], [[0.014149]], [[0.010745]], [[0.007309]], [[0.004454]], [[0.002431]]],
                             [[[0.002568]], [[0.004706]], [[0.007723]], [[0.011353]], [[0.014950]], [[0.017634]], [[0.018632]], [[0.017634]], [[0.014950]], [[0.011353]], [[0.007723]], [[0.004706]], [[0.002568]]],
                             [[[0.002431]], [[0.004454]], [[0.007309]], [[0.010745]], [[0.014149]], [[0.016690]], [[0.017634]], [[0.016690]], [[0.014149]], [[0.010745]], [[0.007309]], [[0.004454]], [[0.002431]]],
                             [[[0.002061]], [[0.003776]], [[0.006196]], [[0.009109]], [[0.011995]], [[0.014149]], [[0.014950]], [[0.014149]], [[0.011995]], [[0.009109]], [[0.006196]], [[0.003776]], [[0.002061]]],
                             [[[0.001565]], [[0.002867]], [[0.004706]], [[0.006918]], [[0.009109]], [[0.010745]], [[0.011353]], [[0.010745]], [[0.009109]], [[0.006918]], [[0.004706]], [[0.002867]], [[0.001565]]],
                             [[[0.001065]], [[0.001950]], [[0.003201]], [[0.004706]], [[0.006196]], [[0.007309]], [[0.007723]], [[0.007309]], [[0.006196]], [[0.004706]], [[0.003201]], [[0.001950]], [[0.001065]]],
                             [[[0.000649]], [[0.001188]], [[0.001950]], [[0.002867]], [[0.003776]], [[0.004454]], [[0.004706]], [[0.004454]], [[0.003776]], [[0.002867]], [[0.001950]], [[0.001188]], [[0.000649]]],
                             [[[0.000354]], [[0.000649]], [[0.001065]], [[0.001565]], [[0.002061]], [[0.002431]], [[0.002568]], [[0.002431]], [[0.002061]], [[0.001565]], [[0.001065]], [[0.000649]], [[0.000354]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==15)&(sigma==3.5)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [7, 7], [7, 7], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.000259]], [[0.000439]], [[0.000686]], [[0.000988]], [[0.001312]], [[0.001607]], [[0.001815]], [[0.001890]], [[0.001815]], [[0.001607]], [[0.001312]], [[0.000988]], [[0.000686]], [[0.000439]],  [[0.000259]]],
                             [[[0.000439]], [[0.000744]], [[0.001162]], [[0.001673]], [[0.002222]], [[0.002722]], [[0.003074]], [[0.003201]], [[0.003074]], [[0.002722]], [[0.002222]], [[0.001673]], [[0.001162]], [[0.000744]],  [[0.000439]]],
                             [[[0.000686]], [[0.001162]], [[0.001815]], [[0.002614]], [[0.003471]], [[0.004251]], [[0.004801]], [[0.005000]], [[0.004801]], [[0.004251]], [[0.003471]], [[0.002614]], [[0.001815]], [[0.001162]],  [[0.000686]]],
                             [[[0.000988]], [[0.001673]], [[0.002614]], [[0.003764]], [[0.005000]], [[0.006123]], [[0.006915]], [[0.007201]], [[0.006915]], [[0.006123]], [[0.005000]], [[0.003764]], [[0.002614]], [[0.001673]],  [[0.000988]]],
                             [[[0.001312]], [[0.002222]], [[0.003471]], [[0.005000]], [[0.006640]], [[0.008132]], [[0.009184]], [[0.009564]], [[0.009184]], [[0.008132]], [[0.006640]], [[0.005000]], [[0.003471]], [[0.002222]],  [[0.001312]]],
                             [[[0.001607]], [[0.002722]], [[0.004251]], [[0.006123]], [[0.008132]], [[0.009960]], [[0.011248]], [[0.011713]], [[0.011248]], [[0.009960]], [[0.008132]], [[0.006123]], [[0.004251]], [[0.002722]],  [[0.001607]]],
                             [[[0.001815]], [[0.003074]], [[0.004801]], [[0.006915]], [[0.009184]], [[0.011248]], [[0.012702]], [[0.013228]], [[0.012702]], [[0.011248]], [[0.009184]], [[0.006915]], [[0.004801]], [[0.003074]],  [[0.001815]]],
                             [[[0.001890]], [[0.003201]], [[0.005000]], [[0.007201]], [[0.009564]], [[0.011713]], [[0.013228]], [[0.013775]], [[0.013228]], [[0.011713]], [[0.009564]], [[0.007201]], [[0.005000]], [[0.003201]],  [[0.001890]]],
                             [[[0.001815]], [[0.003074]], [[0.004801]], [[0.006915]], [[0.009184]], [[0.011248]], [[0.012702]], [[0.013228]], [[0.012702]], [[0.011248]], [[0.009184]], [[0.006915]], [[0.004801]], [[0.003074]],  [[0.001815]]],
                             [[[0.001607]], [[0.002722]], [[0.004251]], [[0.006123]], [[0.008132]], [[0.009960]], [[0.011248]], [[0.011713]], [[0.011248]], [[0.009960]], [[0.008132]], [[0.006123]], [[0.004251]], [[0.002722]],  [[0.001607]]],
                             [[[0.001312]], [[0.002222]], [[0.003471]], [[0.005000]], [[0.006640]], [[0.008132]], [[0.009184]], [[0.009564]], [[0.009184]], [[0.008132]], [[0.006640]], [[0.005000]], [[0.003471]], [[0.002222]],  [[0.001312]]],
                             [[[0.000988]], [[0.001673]], [[0.002614]], [[0.003764]], [[0.005000]], [[0.006123]], [[0.006915]], [[0.007201]], [[0.006915]], [[0.006123]], [[0.005000]], [[0.003764]], [[0.002614]], [[0.001673]],  [[0.000988]]],
                             [[[0.000686]], [[0.001162]], [[0.001815]], [[0.002614]], [[0.003471]], [[0.004251]], [[0.004801]], [[0.005000]], [[0.004801]], [[0.004251]], [[0.003471]], [[0.002614]], [[0.001815]], [[0.001162]],  [[0.000686]]],
                             [[[0.000439]], [[0.000744]], [[0.001162]], [[0.001673]], [[0.002222]], [[0.002722]], [[0.003074]], [[0.003201]], [[0.003074]], [[0.002722]], [[0.002222]], [[0.001673]], [[0.001162]], [[0.000744]],  [[0.000439]]],
                             [[[0.000259]], [[0.000439]], [[0.000686]], [[0.000988]], [[0.001312]], [[0.001607]], [[0.001815]], [[0.001890]], [[0.001815]], [[0.001607]], [[0.001312]], [[0.000988]], [[0.000686]], [[0.000439]],  [[0.000259]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif ((kernel==17)&(sigma==4)):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [8, 8], [8, 8], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.000198]], [[0.000316]], [[0.000473]], [[0.000666]], [[0.000881]], [[0.001095]], [[0.001279]], [[0.001405]], [[0.001449]], [[0.001405]], [[0.001279]], [[0.001095]], [[0.000881]], [[0.000666]], [[0.000473]], [[0.000316]],  [[0.000198]]],
                             [[[0.000316]], [[0.000504]], [[0.000754]], [[0.001062]], [[0.001405]], [[0.001746]], [[0.002040]], [[0.002239]], [[0.002310]], [[0.002239]], [[0.002040]], [[0.001746]], [[0.001405]], [[0.001062]], [[0.000754]], [[0.000504]],  [[0.000316]]],
                             [[[0.000473]], [[0.000754]], [[0.001130]], [[0.001590]], [[0.002104]], [[0.002615]], [[0.003055]], [[0.003354]], [[0.003460]], [[0.003354]], [[0.003055]], [[0.002615]], [[0.002104]], [[0.001590]], [[0.001130]], [[0.000754]],  [[0.000473]]],
                             [[[0.000666]], [[0.001062]], [[0.001590]], [[0.002239]], [[0.002962]], [[0.003682]], [[0.004301]], [[0.004722]], [[0.004871]], [[0.004722]], [[0.004301]], [[0.003682]], [[0.002962]], [[0.002239]], [[0.001590]], [[0.001062]],  [[0.000666]]],
                             [[[0.000881]], [[0.001405]], [[0.002104]], [[0.002962]], [[0.003918]], [[0.004871]], [[0.005690]], [[0.006246]], [[0.006443]], [[0.006246]], [[0.005690]], [[0.004871]], [[0.003918]], [[0.002962]], [[0.002104]], [[0.001405]],  [[0.000881]]],
                             [[[0.001095]], [[0.001746]], [[0.002615]], [[0.003682]], [[0.004871]], [[0.006055]], [[0.007073]], [[0.007764]], [[0.008010]], [[0.007764]], [[0.007073]], [[0.006055]], [[0.004871]], [[0.003682]], [[0.002615]], [[0.001746]],  [[0.001095]]],
                             [[[0.001279]], [[0.002040]], [[0.003055]], [[0.004301]], [[0.005690]], [[0.007073]], [[0.008262]], [[0.009070]], [[0.009356]], [[0.009070]], [[0.008262]], [[0.007073]], [[0.005690]], [[0.004301]], [[0.003055]], [[0.002040]],  [[0.001279]]],
                             [[[0.001405]], [[0.002239]], [[0.003354]], [[0.004722]], [[0.006246]], [[0.007764]], [[0.009070]], [[0.009957]], [[0.010271]], [[0.009957]], [[0.009070]], [[0.007764]], [[0.006246]], [[0.004722]], [[0.003354]], [[0.002239]],  [[0.001405]]],
                             [[[0.001449]], [[0.002310]], [[0.003460]], [[0.004871]], [[0.006443]], [[0.008010]], [[0.009356]], [[0.010271]], [[0.010595]], [[0.010271]], [[0.009356]], [[0.008010]], [[0.006443]], [[0.004871]], [[0.003460]], [[0.002310]],  [[0.001449]]],
                             [[[0.001405]], [[0.002239]], [[0.003354]], [[0.004722]], [[0.006246]], [[0.007764]], [[0.009070]], [[0.009957]], [[0.010271]], [[0.009957]], [[0.009070]], [[0.007764]], [[0.006246]], [[0.004722]], [[0.003354]], [[0.002239]],  [[0.001405]]],
                             [[[0.001279]], [[0.002040]], [[0.003055]], [[0.004301]], [[0.005690]], [[0.007073]], [[0.008262]], [[0.009070]], [[0.009356]], [[0.009070]], [[0.008262]], [[0.007073]], [[0.005690]], [[0.004301]], [[0.003055]], [[0.002040]],  [[0.001279]]],
                             [[[0.001095]], [[0.001746]], [[0.002615]], [[0.003682]], [[0.004871]], [[0.006055]], [[0.007073]], [[0.007764]], [[0.008010]], [[0.007764]], [[0.007073]], [[0.006055]], [[0.004871]], [[0.003682]], [[0.002615]], [[0.001746]],  [[0.001095]]],
                             [[[0.000881]], [[0.001405]], [[0.002104]], [[0.002962]], [[0.003918]], [[0.004871]], [[0.005690]], [[0.006246]], [[0.006443]], [[0.006246]], [[0.005690]], [[0.004871]], [[0.003918]], [[0.002962]], [[0.002104]], [[0.001405]],  [[0.000881]]],
                             [[[0.000666]], [[0.001062]], [[0.001590]], [[0.002239]], [[0.002962]], [[0.003682]], [[0.004301]], [[0.004722]], [[0.004871]], [[0.004722]], [[0.004301]], [[0.003682]], [[0.002962]], [[0.002239]], [[0.001590]], [[0.001062]],  [[0.000666]]],
                             [[[0.000473]], [[0.000754]], [[0.001130]], [[0.001590]], [[0.002104]], [[0.002615]], [[0.003055]], [[0.003354]], [[0.003460]], [[0.003354]], [[0.003055]], [[0.002615]], [[0.002104]], [[0.001590]], [[0.001130]], [[0.000754]],  [[0.000473]]],
                             [[[0.000316]], [[0.000504]], [[0.000754]], [[0.001062]], [[0.001405]], [[0.001746]], [[0.002040]], [[0.002239]], [[0.002310]], [[0.002239]], [[0.002040]], [[0.001746]], [[0.001405]], [[0.001062]], [[0.000754]], [[0.000504]],  [[0.000316]]],
                             [[[0.000198]], [[0.000316]], [[0.000473]], [[0.000666]], [[0.000881]], [[0.001095]], [[0.001279]], [[0.001405]], [[0.001449]], [[0.001405]], [[0.001279]], [[0.001095]], [[0.000881]], [[0.000666]], [[0.000473]], [[0.000316]],  [[0.000198]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net

## Num. 2
def Average_filtering(inp, kernel=5, name='Attack_2'):
    if (kernel==3):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [1, 1], [1, 1], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.11111]], [[0.11111]], [[0.11111]]], 
                             [[[0.11111]], [[0.11111]], [[0.11111]]], 
                             [[[0.11111]], [[0.11111]], [[0.11111]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif (kernel==5):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [2, 2], [2, 2], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.04]], [[0.04]], [[0.04]], [[0.04]], [[0.04]]],
                             [[[0.04]], [[0.04]], [[0.04]], [[0.04]], [[0.04]]],
                             [[[0.04]], [[0.04]], [[0.04]], [[0.04]], [[0.04]]], 
                             [[[0.04]], [[0.04]], [[0.04]], [[0.04]], [[0.04]]], 
                             [[[0.04]], [[0.04]], [[0.04]], [[0.04]], [[0.04]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net

def Average_filtering_test(inp, kernel=5, name='Attack_2'):
    if (kernel==3):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [1, 1], [1, 1], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.11111]], [[0.11111]], [[0.11111]]], 
                             [[[0.11111]], [[0.11111]], [[0.11111]]], 
                             [[[0.11111]], [[0.11111]], [[0.11111]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif (kernel==5):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [2, 2], [2, 2], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.04]], [[0.04]], [[0.04]], [[0.04]], [[0.04]]],
                             [[[0.04]], [[0.04]], [[0.04]], [[0.04]], [[0.04]]],
                             [[[0.04]], [[0.04]], [[0.04]], [[0.04]], [[0.04]]], 
                             [[[0.04]], [[0.04]], [[0.04]], [[0.04]], [[0.04]]], 
                             [[[0.04]], [[0.04]], [[0.04]], [[0.04]], [[0.04]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net

## Num. 3
def Salt_and_Pepper(inp, p=0.1, name='Attack_3'):

    bs = inp.get_shape()[0].value
    h = inp.get_shape()[1].value
    w = inp.get_shape()[2].value

    maxi = tf.ones([bs, int(h*w*(p/2)+0.5)])
    maxi = tf.multiply(maxi, 1)
    mini = tf.ones([bs, int(h*w*p+0.5)-int(h*w*(p/2)+0.5)])
    mini = tf.multiply(mini, -1)
    stay = tf.zeros([bs, h*w-int(h*w*p+0.5)])
    net = tf.concat([maxi, mini, stay], axis=1)
    net = tf.random_shuffle(net)
    net = tf.transpose(net, [1, 0])
    net = tf.random_shuffle(net)
    net = tf.transpose(net, [1, 0])
    net = tf.reshape(net, inp.get_shape())
    net = tf.add(net, inp)
    return net

## Num. 4
def Gaussian_Noise(inp, sigma=0.1, name='Attack_4'):

    norm = tf.random_normal(inp.get_shape(), mean=0, stddev=sigma)
    net = tf.add(norm, inp)
    return net

## Num. 5
def Sharpening(inp, center=9, name='Attack_5'):
    if (center==5):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [1, 1,], [1, 1], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.0]], [[-1.0]], [[0.0]]], 
                             [[[-1.0]], [[5.0]], [[-1.0]]], 
                             [[[0.0]], [[-1.0]], [[0.0]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif (center==9):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [1, 1,], [1, 1], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[-1.0]], [[-1.0]], [[-1.0]]], 
                             [[[-1.0]], [[9.0]], [[-1.0]]], 
                             [[[-1.0]], [[-1.0]], [[-1.0]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net

def Sharpening_test(inp, center=9, name='Attack_5'):
    if (center==5):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [1, 1,], [1, 1], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[0.0]], [[-1.0]], [[0.0]]], 
                             [[[-1.0]], [[5.0]], [[-1.0]]], 
                             [[[0.0]], [[-1.0]], [[0.0]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net
    elif (center==9):
        with tf.variable_scope(name, reuse=True):
            pad = tf.constant([[0, 0], [1, 1,], [1, 1], [0, 0]])
            inp = tf.pad(inp, pad, "SYMMETRIC")
            w = tf.constant([[[[-1.0]], [[-1.0]], [[-1.0]]], 
                             [[[-1.0]], [[9.0]], [[-1.0]]], 
                             [[[-1.0]], [[-1.0]], [[-1.0]]]], dtype=tf.float32)
            net = tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID')
        return net

## Num. 6
def Rescaling(inp, name='Attack_6'):
    h = int(inp.get_shape()[1])
    w = int(inp.get_shape()[2])
    ratio =  np.random.uniform(0.4, 1)
    net = tf.image.resize_images(inp, [int(h*ratio),  int(w*ratio)], method=tf.image.ResizeMethod.BILINEAR, \
                                       preserve_aspect_ratio=True, align_corners=False)
    net = tf.image.resize_images(net, [h, w], method=tf.image.ResizeMethod.BILINEAR, \
                                       preserve_aspect_ratio=True, align_corners=False)
    return net

def Rescaling_test(inp, ratio=0.5, name='Attack_6'):
    h = int(inp.get_shape()[1])
    w = int(inp.get_shape()[2])
    #ratio =  tf.random_uniform([int(inp.get_shape()[0])], 0.4, 1, dtype=tf.float32)
    net = tf.image.resize_images(inp, [int(h*ratio),  int(w*ratio)], method=tf.image.ResizeMethod.BILINEAR, \
                                       preserve_aspect_ratio=True, align_corners=False)
    net = tf.image.resize_images(net, [h, w], method=tf.image.ResizeMethod.BILINEAR, \
                                       preserve_aspect_ratio=True, align_corners=False)
    return net

def Rescaling_test_v2(inp, ratio=0.5, name='Attack_6'):
    h = int(inp.get_shape()[1])
    w = int(inp.get_shape()[2])
    #ratio =  tf.random_uniform([int(inp.get_shape()[0])], 0.4, 1, dtype=tf.float32)
    net = tf.image.resize_images(inp, [int(h*ratio),  int(w*ratio)], method=tf.image.ResizeMethod.BILINEAR, \
                                       preserve_aspect_ratio=True, align_corners=False)
    net = tf.image.central_crop(net, 1/ratio)
    #net = tf.image.resize_images(net, [h, w], method=tf.image.ResizeMethod.BILINEAR, \
    #                                   preserve_aspect_ratio=True, align_corners=False)
    return net

## Num. 7
def Cropping(inp, ratio=0.5, name='Attack_7'):
    inp = tf.divide(tf.add(inp, 1), 2)
    h = int(inp.get_shape()[1])
    w = int(inp.get_shape()[2])
    ratio = np.sqrt(ratio)
    offset_height = tf.random_uniform([], 0, 1-ratio)
    offset_width = tf.random_uniform([], 0, 1-ratio)
    x_min = tf.cast(offset_height * tf.cast(h, tf.float32), tf.int32)
    y_min = tf.cast(offset_width * tf.cast(w, tf.float32), tf.int32)
    black_box = tf.ones([int(inp.get_shape()[0]), int(h*ratio), int(w*ratio), 1], dtype=tf.float32)
    mask = tf.subtract(1.0, tf.image.pad_to_bounding_box(black_box, x_min, y_min, h, w))
    net = tf.multiply(inp, mask)
    net = tf.multiply(tf.subtract(net, 0.5), 2)
    return net

## Num. 8
def Rotation(inp, name='Attack_8',angle=45):
    # anlge : batch당 다르게 가능 
    #angle = tf.random_uniform([int(inp.get_shape()[0])], 0, 91, dtype=tf.float32)
    pi = 3.14159265359
    net = tf.contrib.image.rotate(inp, angles=(pi/180)*angle, interpolation='NEAREST')
    net = tf.contrib.image.rotate(net, angles=-(pi/180)*angle, interpolation='NEAREST')
    return net

def Rotation_test(inp, name='Attack_8', angle=45):
    inp = tf.divide(tf.add(inp, 1), 2)
    # anlge : batch당 다르게 가능 
    #angle = tf.random_uniform([int(inp.get_shape()[0])], 0, 91, dtype=tf.float32)
    pi = 3.14159265359
    net = tf.contrib.image.rotate(inp, angles=(pi/180)*angle, interpolation='NEAREST')
    net = tf.contrib.image.rotate(net, angles=-(pi/180)*angle, interpolation='NEAREST')
    net = tf.multiply(tf.subtract(net, 0.5), 2)
    return net

def Rotation_test_v2(inp, name='Attack_8', angle=45):
    # anlge : batch당 다르게 가능 
    #angle = tf.random_uniform([int(inp.get_shape()[0])], 0, 91, dtype=tf.float32)
    pi = 3.14159265359
    net = tf.contrib.image.rotate(inp, angles=(pi/180)*angle, interpolation='NEAREST')
    return net

### Num. 9
#def Row_and_Column_Removal(inp, name='Attack_9'):
    #h = int(inp.get_shape()[1])
    #w = int(inp.get_shape()[2])
    #row_or_col = tf.random_uniform([], 0, 2, dtype=tf.int32)
    #zeros = tf.zeros([1, w])
    #ones = tf.ones([h-1, w])
    #mask = tf.concat([zeros, ones], 0)
    #mask = tf.random_shuffle(mask)
    #
    #if(row_or_col==1):
    #    mask = tf.transpose(mask, [1, 0])
    #mask = tf.reshape(mask, [1, h, w, 1])
    #net = tf.multiply(inp, mask)
    #return net

### Num. 10
#def General_affine_tr(inp, name='Attack_10'):
    # transforms : batch당 다르게 가능 
    #trans = tf.constant([[1, 0, 0], 
    #                     [0, 1, 0], 
    #                     [0, 0, 1]], dtype=tf.float32)
    #trans_inv = tf.linalg.inv(trans)
    #net = tf.contrib.image.transform(inp, transforms=tf.concat([trans.flatten()[:6], [0, 0]], 0), \
    #                                      interpolation='NEAREST', output_shape=None)
    #net = tf.contrib.image.transform(net, transforms=tf.concat([trans_inv, [0, 0]]), \
    #                                      interpolation='NEAREST', output_shape=None)
    #return net
#
# Num. 11
def Contrast(inp, factor=5, name='Attack_11'):
    net = tf.image.adjust_contrast(inp, factor)
    return net

## Num. 12
def Gamma_Correction(inp, gamma=0.3, name='Attack_12'):
    net = tf.image.adjust_gamma(inp, gamma=1/gamma, gain=1)
    return net

## Num. 13
def JPEG(inp, quality=50, name='Attack_13'):
    inp = tf.divide(tf.add(inp, 1), 2)
    net = []
    for i in range(inp.get_shape()[0]):
        inp_ = inp[i, :, :, :]
        net_ = tf.image.adjust_jpeg_quality(inp_, quality)
        net.append(net_)
    net = tf.convert_to_tensor(net)
    net = tf.reshape(net, [inp.get_shape()[0], inp.get_shape()[1], inp.get_shape()[2], 1])
    net = tf.multiply(tf.subtract(net, 0.5), 2)
    return net

## Num. 14
def Grid_Crop_test(inp, ratio=0.8, name='Grid_Crop'):   
    inp = tf.divide(tf.add(inp, 1), 2) 
    h = int(inp.get_shape()[1])
    w = int(inp.get_shape()[2])
    #ratio = tf.random_uniform([int(inp.get_shape()[0])], 0.7, 0.9, dtype=tf.float32)
    ratio = np.sqrt(ratio)
    offset_height = tf.random_uniform([], 0, 1-ratio)
    offset_width = tf.random_uniform([], 0, 1-ratio)
    x_min = tf.cast(offset_height * tf.cast(h, tf.float32), tf.int32)
    y_min = tf.cast(offset_width * tf.cast(w, tf.float32), tf.int32)
    black_box = tf.ones([int(inp.get_shape()[0]), int(h*ratio), int(w*ratio), 1], dtype=tf.float32)
    mask = tf.image.pad_to_bounding_box(black_box, x_min, y_min, h, w)
    net = tf.multiply(inp, mask)
    net = tf.multiply(tf.subtract(net, 0.5), 2)
    return net

## Num. 15
def Dropout(inp, ori, name='Attack_15'):

    bs = inp.get_shape()[0].value
    h = inp.get_shape()[1].value
    w = inp.get_shape()[2].value

    p =  np.random.uniform(0.3, 0.9)
    stay = tf.ones([bs, int(h*w*p+0.5)])
    host = tf.zeros([bs, h*w-int(h*w*p+0.5)])
    net = tf.concat([stay, host], axis=1)
    net = tf.random_shuffle(net)
    net = tf.transpose(net, [1, 0])
    net = tf.random_shuffle(net)
    net = tf.transpose(net, [1, 0])
    net = tf.reshape(net, inp.get_shape())
    stay = tf.multiply(net, inp)
    net = tf.subtract(net, 1)
    net = tf.abs(net)
    host = tf.multiply(net, ori)
    net = tf.add(stay, host)
    return net

## Num. 15
def Dropout_test(inp, ori, p, name='Attack_15'):

    bs = inp.get_shape()[0].value
    h = inp.get_shape()[1].value
    w = inp.get_shape()[2].value

    #p =  np.random.uniform(0.3, 0.9)
    stay = tf.ones([bs, int(h*w*p+0.5)])
    host = tf.zeros([bs, h*w-int(h*w*p+0.5)])
    net = tf.concat([stay, host], axis=1)
    net = tf.random_shuffle(net)
    net = tf.transpose(net, [1, 0])
    net = tf.random_shuffle(net)
    net = tf.transpose(net, [1, 0])
    net = tf.reshape(net, inp.get_shape())
    stay = tf.multiply(net, inp)
    net = tf.subtract(net, 1)
    net = tf.abs(net)
    host = tf.multiply(net, ori)
    net = tf.add(stay, host)
    return net

## Num. 16
def Median_filter(inp, kernel=3, name='Attack_16'):
    pad = tf.constant([[0, 0], [int((kernel-1)/2), int((kernel-1)/2)], [int((kernel-1)/2), int((kernel-1)/2)], [0, 0]])
    inp = tf.pad(inp, pad, "SYMMETRIC")
    patches = tf.extract_image_patches(inp, [1, kernel, kernel, 1], [1, 1, 1, 1], 4*[1], 'VALID')
    #print(patches)
    medians = tf.contrib.distributions.percentile(patches, 50, axis=3)
    medians = tf.reshape(medians, [medians.get_shape()[0], medians.get_shape()[1], medians.get_shape()[2], 1])
    #print(medians)
    return medians

def Median_filter_test(inp, kernel=3, name='Attack_16'):
    pad = tf.constant([[0, 0], [int((kernel-1)/2), int((kernel-1)/2)], [int((kernel-1)/2), int((kernel-1)/2)], [0, 0]])
    inp = tf.pad(inp, pad, "SYMMETRIC")
    patches = tf.extract_image_patches(inp, [1, kernel, kernel, 1], [1, 1, 1, 1], 4*[1], 'VALID')
    #print(patches)
    medians = tf.contrib.distributions.percentile(patches, 50, axis=3)
    medians = tf.reshape(medians, [medians.get_shape()[0], medians.get_shape()[1], medians.get_shape()[2], 1])
    #print(medians)
    return medians

if __name__ == '__main__':
    attack = ['Gaussian_filtering', 'Average_filtering', 'Salt_and_Pepper', 'Gaussian_Noise',
              'Sharpening', 'Rescaling', 'Cropping', 'Rotation', 'Row_and_Column_Removal',
              'General_affine_tr', 'Contrast', 'Gamma_Correction', 'JPEG']

    img1 = Image.open('./attack_img/00_original.png') 
    img2 = Image.open('./attack_img/00_original_2.png') 
    ori_img1 = np.asarray(img1)
    ori_img2 = np.asarray(img2)
    img1 = ori_img1.astype(np.float32).reshape([1, 128, 128, 1])
    img2 = ori_img2.astype(np.float32).reshape([1, 128, 128, 1])
    img = np.concatenate([img1, img2], 0)
    a = tf.placeholder(tf.float32, [2, 128, 128, 1])
    for mode in [3]:
        if (mode==1):
            out = Gaussian_filtering(a)
        elif (mode==2):
            out = Average_filtering(a)
        elif (mode==3):
            out = Salt_and_Pepper(a)
        elif (mode==4):
            out = Gaussian_Noise(a)
        elif (mode==5):
            out = Sharpening(a)
        elif (mode==6):
            out = Rescaling(a)
        elif (mode==7):
            out = Cropping(a)
        elif (mode==8):
            out = Rotation(a)
        elif (mode==9):
            out = Row_and_Column_Removal(a)
        elif (mode==10):
            out = General_affine_tr(a)
        elif (mode==11):
            out = Contrast(a)
        elif (mode==12):
            out = Gamma_Correction(a)
        elif (mode==13):
            out = JPEG(a)

        out = tf.clip_by_value(out, 0, 255)
        sess = tf.Session(config=tf.ConfigProto(device_count={'GPU':0}))
        sess.run(tf.global_variables_initializer())
        out_img = sess.run(out, feed_dict={a:img})
        out_img = out_img.astype(np.uint8).reshape([-1, out_img.shape[1], out_img.shape[1]])
        print(out_img.shape)

        mse = np.mean((ori_img1-out_img[0])**2)
        PSNR1 = 10*np.log10((255**2)/mse)

        mse = np.mean((ori_img2-out_img[1])**2)
        PSNR2 = 10*np.log10((255**2)/mse)

        print(mode, attack[mode-1], PSNR1, PSNR2)

        scipy.misc.toimage(out_img[0], cmin=0.0, cmax=255.0).save("./attack_img/%02d_%s.png" % (mode, attack[mode-1]))  
        scipy.misc.toimage(out_img[1], cmin=0.0, cmax=255.0).save("./attack_img/%02d_%s_2.png" % (mode, attack[mode-1]))    
        #print(out)